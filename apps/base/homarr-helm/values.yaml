homarr:
  # Keep single replica until DB cutover validated
  replicaCount: 2
  # RWO PVC -> Recreate on helm upgrades to avoid volume attach conflicts
  strategyType: Recreate

  image:
    repository: ghcr.io/homarr-labs/homarr
    pullPolicy: IfNotPresent
    tag: "v1.36.1"

  env:
    TZ: "America/Los_Angeles"
    REDIS_URL: "redis://homarr-helm-redis-master.homarr.svc.cluster.local:6379/0"

  # Keep encryption key in existing secret 'homarr-env'
  envSecrets:
    dbCredentials:
      existingSecret: "homarr-env"
      dbEncryptionKey: "SECRET_ENCRYPTION_KEY"
      dbUrlKey: "DB_URL"

  # Built-in health endpoints (match current deployment)
  livenessProbe:
    httpGet:
      path: /api/health/live
      port: 7575

  readinessProbe:
    httpGet:
      path: /api/health/ready
      port: 7575

  # Container and Service ports
  containerPorts:
    http:
      port: 7575
      protocol: TCP

  service:
    enabled: true
    type: ClusterIP
    ports:
      app:
        port: 80
        targetPort: http
        protocol: TCP

  # Disable ingress for side-by-side bring-up (avoid host conflict).
  # We will enable at cutover and turn off the old ingress.
  ingress:
    enabled: true
    ingressClassName: haproxy-restricted
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
    hosts:
      - host: homarr.rcrumana.xyz
        paths:
          - path: /
    tls:
      - secretName: homarr-tls
        hosts:
          - homarr.rcrumana.xyz

  # Preserve current resources
  resources:
    limits:
      cpu: "1"
      memory: 2Gi
    requests:
      cpu: "50m"
      memory: 256Mi

  # Spread Homarr pods across nodes (soft), but allow scheduling when a node is down
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            topologyKey: kubernetes.io/hostname
            labelSelector:
              matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                    - homarr
                - key: app.kubernetes.io/instance
                  operator: In
                  values:
                    - homarr-helm

  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
              - homarr
          - key: app.kubernetes.io/instance
            operator: In
            values:
              - homarr-helm

  # Persist /appdata using the existing PVC
  persistence:
    homarrDatabase:
      enabled: true
      # Bind to the existing PV behind the homarr-appdata-protected PVC to avoid creating a new claim
      name: "homarr-database"
      volumeClaimName: ""
      storageClassName: "longhorn-protected"
      accessMode: "ReadWriteOnce"
      size: "1Gi"
      mountPath: "/appdata"

  rbac:
    enabled: false

  # Avoid resource name collisions with existing Kustomize deployment
  nameOverride: "homarr-helm"
  fullnameOverride: "homarr-helm"

  # External DB is configured via mysql dependency below (see root-level mysql: values)

  # Homarr chart DB flags
  database:
    externalDatabaseEnabled: true
    migrationEnabled: true

# Database subchart: Bitnami MySQL (replication)
mysql:
  architecture: replication
  auth:
    existingSecret: "homarr-mysql-secret"
    username: "homarr"
    database: "homarrdb"
  primary:
    persistence:
      enabled: true
      storageClass: "longhorn-protected"
      size: 2Gi
    # Prefer primary on a different node than secondaries, but allow scheduling on single-node
    podAntiAffinityPreset: soft
    topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: mysql
            app.kubernetes.io/instance: homarr-helm
  secondary:
    replicaCount: 1
    persistence:
      enabled: true
      storageClass: "longhorn-protected"
      size: 2Gi
    # Prefer secondaries on a different node than primary/each other where possible
    podAntiAffinityPreset: soft
    topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: mysql
            app.kubernetes.io/instance: homarr-helm

# Session store subchart: Bitnami Redis (replication)
redis:
  architecture: replication
  auth:
    enabled: false
  master:
    persistence:
      enabled: true
      storageClass: "longhorn-protected"
      size: 1Gi
    # Prefer Redis master on a different node than replicas where possible
    podAntiAffinityPreset: soft
    topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: redis
            app.kubernetes.io/instance: homarr-helm
  replica:
    replicaCount: 1
    persistence:
      enabled: true
      storageClass: "longhorn-protected"
      size: 1Gi
    # Prefer Redis replicas on a different node than master/each other where possible
    podAntiAffinityPreset: soft
    topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app.kubernetes.io/name: redis
            app.kubernetes.io/instance: homarr-helm